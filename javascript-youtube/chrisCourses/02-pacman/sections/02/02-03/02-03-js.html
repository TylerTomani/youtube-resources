(function () {<div class="code-container"><pre tabindex="0" class="copy-code">
const canvas = document.querySelector('canvas')
const c = canvas.getContext('2d')
canvas.width = innerWidth
canvas.height = innerHeight * .7
<div class="code-container"><pre tabindex="0" class="copy-code"><span class="b-fix">let</span> <span class="lsg-fix">canavsRect</span>
<span class="b-fix">let</span> <span class="lsg-fix">clickX</span>
<span class="b-fix">let</span> <span class="lsg-fix">clickY</span>
<span class="g">/** Get this so when first container is clicked this 
    gets focused, AND when steps are clicked, this pop up follows the 
    step-txt and shows the change in the code in this popup
*/</span></pre></div>
let lastKey = ''
let playerSpeed = 2</pre></div>
<div class="code-container"><pre tabindex="0" class="copy-code">
const keys = {
    up:{
        pressed: false
    },
    right:{
        pressed: false
    },
    down: {
        pressed: false
    }
    ,
    left:{
        pressed: false
    }
}</pre></div>
//Boundary Class
<div class="code-container"><pre tabindex="0" class="copy-code">

class Boundary {
    static width = 30
    static height = 30
    constructor({ position }) {
        this.position = position
        this.width = 30
        this.height = 30
    }
    draw() {
        c.fillStyle = 'blue'
        c.fillRect(this.position.x, this.position.y, this.width, this.height)

    }
}</pre></div>
//Pacman Class
<div class="code-container">
    <pre tabindex="0" class="copy-code">
//Pacman
class Pacman {
    constructor({ position, velocity }) {
        this.position = position
        this.velocity = velocity
        this.radius = 15
    }
    draw() {
        c.beginPath()
        c.fillStyle = 'yellow'
        c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2)
        c.fill()
        c.closePath()
    }
    update(){
        this.position.x += this.velocity.x
        this.position.y += this.velocity.y
        this.draw()
    }
}
const pacman = new Pacman({
    position: {
        x: Boundary.width + (Boundary.width * .5),
        y: Boundary.height + (Boundary.height * .5),
    },
    velocity: {
        x: 0,
        y: 0
    }
})</pre></div>
// Boundaries & Map
<div class="code-container"><pre tabindex="0" class="copy-code">
const map = [
    ['-', '-', '-', '-', '-', '-'],
    ['-', ' ', ' ', ' ', ' ', '-'],
    ['-', ' ', '-', '-', ' ', '-'],
    ['-', ' ', ' ', ' ', ' ', '-'],
    ['-', '-', '-', '-', '-', '-']
]
const boundaries = []
map.forEach((row, i) => {
    row.forEach((symbol, j) => {
        switch (symbol) {
            case '-':
                boundaries.push(new Boundary({
                    position: {
                        x: Boundary.width * j,
                        y: Boundary.height * i
                    }
                }))
                break
        }
    })
})</pre></div>
// Mouse Click
<div class="code-container"><pre tabindex="0" class="copy-code">
canvas.addEventListener('mouseup', e => {
    keys.up.pressed = false
    keys.right.pressed = false
    keys.down.pressed = false
    keys.left.pressed = false
})
canvas.addEventListener('mousedown', e => {
    canavsRect = canvas.getBoundingClientRect();
    clickX = e.clientX - canavsRect.left;
    clickY = e.clientY - canavsRect.top;
});</pre></div>

</div>
<div class="code-container"><pre tabindex="0" class="copy-code">
function animate(){
    requestAnimationFrame(animate)
    c.fillStyle = 'black'
    c.fillRect(0, 0, canvas.width, canvas.height)
    pacman.velocity.x = 0
    pacman.velocity.y = 0
    if (keys.up.pressed && lastKey != 'up') {
        pacman.velocity.y -= playerSpeed
    }else if(keys.right.pressed && lastKey != 'right'){
        pacman.velocity.x += playerSpeed
    } else if (keys.left.pressed && lastKey != 'left'){
        pacman.velocity.x -= playerSpeed
    }else if (keys.down.pressed && lastKey != 'down'){
        pacman.velocity.y += playerSpeed
    } 
    boundaries.forEach(el => {
        el.draw()
    })
    pacman.update()
}
animate()</pre></div>

}())
